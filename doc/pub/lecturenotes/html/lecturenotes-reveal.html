<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html lecturenotes-reveal.html lecturenotes-reveal reveal --html_slide_theme=beige
-->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Using Machine Learning to Classify Phase Transitions">
<title>Using Machine Learning to Classify Phase Transitions</title>

<!-- reveal.js: https://lab.hakim.se/reveal-js/ -->

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<!--
<link rel="stylesheet" href="reveal.js/css/reveal.css">
<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/beigesmall.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/solarized.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/serif.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/moon.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/darkgray.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/cbc.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/simula.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
<link rel="stylesheet" href="reveal.js/css/theme/league.css" id="theme">
-->

<!-- For syntax highlighting -->
<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<style type="text/css">
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.reveal .alert-text-small   { font-size: 80%;  }
.reveal .alert-text-large   { font-size: 130%; }
.reveal .alert-text-normal  { font-size: 90%;  }
.reveal .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
  -webkit-border-radius: 14px; -moz-border-radius: 14px;
  border-radius:14px;
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.reveal .alert-block {padding-top:14px; padding-bottom:14px}
.reveal .alert-block > p, .alert-block > ul {margin-bottom:1em}
/*.reveal .alert li {margin-top: 1em}*/
.reveal .alert-block p+p {margin-top:5px}
/*.reveal .alert-notice { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_notice.png); }
.reveal .alert-summary  { background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_summary.png); }
.reveal .alert-warning { background-image: url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_warning.png); }
.reveal .alert-question {background-image:url(https://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */
/* Override reveal.js table border */
.reveal table td {
  border: 0;
}

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:5px solid #bababa;
    -webkit-border-radius:14px; -moz-border-radius:14px;
  border-radius:14px
  background-position: 10px 10px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 30px; /* 55px; if icon */
}
.slide .alert-block {padding-top:14px; padding-bottom:14px}
.slide .alert-block > p, .alert-block > ul {margin-bottom:0}
/*.slide .alert li {margin-top: 1em}*/
.deck .alert-block p+p {margin-top:5px}
/*.slide .alert-notice { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_notice.png); }
.slide .alert-summary  { background-image:url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_summary.png); }
.slide .alert-warning { background-image: url(https://hplgit.github.io/doconce/
bundled/html_images//small_gray_warning.png); }
.slide .alert-question {background-image:url(https://hplgit.github.io/doconce/
bundled/html_images/small_gray_question.png); } */
.dotable table, .dotable th, .dotable tr, .dotable tr td {
  border: 2px solid black;
  border-collapse: collapse;
  padding: 2px;
}
</style>


<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>


<body>
<div class="reveal">
<div class="slides">





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<section>
<!-- ------------------- main content ---------------------- -->
<center>
<h1 style="text-align: center;">Using Machine Learning to Classify Phase Transitions</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> 
</center>
<!-- institution -->
<center>
<b>Department of Physics and Center for Computing in Science Education, University of Oslo, Norway</b>
</center>
<br>
<center>
<h4>CEACM Flagship School: Machine Learning in Physical Sciences: Theory and Applications, May 26-30, 2025</h4>
</center> <!-- date -->
<br>
</section>

<section>
<h2 id="what-is-this-about">What is this about? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>These notes, with pertinent exercises cover the following topics. </p>
<ol>
<p><li> Phase Transitions &amp; Critical Phenomena: Definitions and key concepts (order parameters, critical points, first vs second order).</li>
<p><li> Spin Models: 2D Ising model and the q-state Potts model (examples of phase transitions).</li>
<p><li> Data Generation: Monte Carlo simulations for sampling spin configurations across temperatures.</li>
<p><li> Unsupervised Learning (PCA): Principal Component Analysis to visualize phase separation without labels.</li>
<p><li> Supervised Learning (CNN): Convolutional Neural Networks for classifying phases from raw configurations.</li>
<p><li> Generative Models (VAE): Variational Autoencoders for latent representation learning and critical anomaly detection.</li>
<p><li> Comparisons: Interpretability and performance trade-offs between PCA, CNN, and VAE.</li>
</ol>
</div>
</section>

<section>
<h2 id="where-do-i-find-the-material">Where do I find the material? </h2>

<p>All the material here can be found in the PDF files, codes and jupyter-notebooks at the above <b>doc</b> folder, see the <b>pub</b> subfolder, see <a href="https://github.com/CompPhysics/CecamMay2025" target="_blank"><tt>https://github.com/CompPhysics/CecamMay2025</tt></a></p>
</section>

<section>
<h2 id="ai-ml-and-some-statements-you-may-have-heard-and-what-do-they-mean">AI/ML and some statements you may have heard (and what do they mean?)  </h2>

<ol>
<p><li> Fei-Fei Li on ImageNet: <b>map out the entire world of objects</b> (<a href="https://cacm.acm.org/news/219702-the-data-that-transformed-ai-research-and-possibly-the-world/fulltext" target="_blank">The data that transformed AI research</a>)</li>
<p><li> Russell and Norvig in their popular textbook: <b>relevant to any intellectual task; it is truly a universal field</b> (<a href="http://aima.cs.berkeley.edu/" target="_blank">Artificial Intelligence, A modern approach</a>)</li>
<p><li> Woody Bledsoe puts it more bluntly: <b>in the long run, AI is the only science</b> (quoted in Pamilla McCorduck, <a href="https://www.pamelamccorduck.com/machines-who-think" target="_blank">Machines who think</a>)</li>
</ol>
<p>
<p>If you wish to have a critical read on AI/ML from a societal point of view, see <a href="https://www.katecrawford.net/" target="_blank">Kate Crawford's recent text Atlas of AI</a>. </p>

<b>Here: with AI/ML we intend a collection of machine learning methods with an emphasis on statistical learning and data analysis</b>
</section>

<section>
<h2 id="types-of-machine-learning">Types of machine learning </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>The approaches to machine learning are many, but are often split into two main categories. 
In <em>supervised learning</em> we know the answer to a problem,
and let the computer deduce the logic behind it. On the other hand, <em>unsupervised learning</em>
is a method for finding patterns and relationship in data sets without any prior knowledge of the system.
</p>

<p>An important  third category is  <em>reinforcement learning</em>. This is a paradigm 
of learning inspired by behavioural psychology, where learning is achieved by trial-and-error, 
solely from rewards and punishment.
</p>
</div>
</section>

<section>
<h2 id="main-categories">Main categories </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Another way to categorize machine learning tasks is to consider the desired output of a system.
Some of the most common tasks are:
</p>

<ul>

<p><li> Classification: Outputs are divided into two or more classes. The goal is to   produce a model that assigns inputs into one of these classes. An example is to identify  digits based on pictures of hand-written ones. Classification is typically supervised learning.</li>

<p><li> Regression: Finding a functional relationship between an input data set and a reference data set.   The goal is to construct a function that maps input data to continuous output values.</li>

<p><li> Clustering: Data are divided into groups with certain common traits, without knowing the different groups beforehand.  It is thus a form of unsupervised learning.</li>
</ul>
</div>
</section>

<section>
<h2 id="the-plethora-of-machine-learning-algorithms-methods">The plethora  of machine learning algorithms/methods </h2>

<ol>
<p><li> Deep learning: Neural Networks (NN), Convolutional NN, Recurrent NN, Boltzmann machines, autoencoders and variational autoencoders  and generative adversarial networks, stable diffusion and many more generative models</li>
<p><li> Bayesian statistics and Bayesian Machine Learning, Bayesian experimental design, Bayesian Regression models, Bayesian neural networks, Gaussian processes and much more</li>
<p><li> Dimensionality reduction (Principal component analysis), Clustering Methods and more</li>
<p><li> Ensemble Methods, Random forests, bagging and voting methods, gradient boosting approaches</li> 
<p><li> Linear and logistic regression, Kernel methods, support vector machines and more</li>
<p><li> Reinforcement Learning; Transfer Learning and more</li> 
</ol>
</section>

<section>
<h2 id="example-of-generative-modeling-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Example of generative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativelearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="example-of-discriminative-modeling-taken-from-generative-deeep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Example of discriminative modeling, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deeep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/standarddeeplearning.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="taxonomy-of-generative-deep-learning-taken-from-generative-deep-learning-by-david-foster-https-www-oreilly-com-library-view-generative-deep-learning-9781098134174-ch01-html">Taxonomy of generative deep learning, <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">taken from Generative Deep Learning by David Foster</a>  </h2>

<br/><br/>
<center>
<p><img src="figures/generativemodels.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="good-books-with-hands-on-material-and-codes">Good books with hands-on material and codes </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> <a href="https://sebastianraschka.com/blog/2022/ml-pytorch-book.html" target="_blank">Sebastian Rashcka et al, Machine learning with Sickit-Learn and PyTorch</a></li>
<p><li> <a href="https://www.oreilly.com/library/view/generative-deep-learning/9781098134174/ch01.html" target="_blank">David Foster, Generative Deep Learning with TensorFlow</a></li>
<p><li> <a href="https://github.com/PacktPublishing/Hands-On-Generative-AI-with-Python-and-TensorFlow-2" target="_blank">Bali and Gavras, Generative AI with Python and TensorFlow 2</a></li>
</ul>
</div>

<p>All three books have GitHub addresses from where  one can download all codes. We will borrow most of the material from these three texts as well as 
from Goodfellow, Bengio and Courville's text <a href="https://www.deeplearningbook.org/" target="_blank">Deep Learning</a>
</p>
</section>

<section>
<h2 id="what-are-the-basic-machine-learning-ingredients">What are the basic Machine Learning ingredients? </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<p>Almost every problem in ML and data science starts with the same ingredients:</p>
<ul>
<p><li> The dataset \( \boldsymbol{x} \) (could be some observable quantity of the system we are studying)</li>
<p><li> A model which is a function of a set of parameters \( \boldsymbol{\alpha} \) that relates to the dataset, say a likelihood  function \( p(\boldsymbol{x}\vert \boldsymbol{\alpha}) \) or just a simple model \( f(\boldsymbol{\alpha}) \)</li>
<p><li> A so-called <b>loss/cost/risk</b> function \( \mathcal{C} (\boldsymbol{x}, f(\boldsymbol{\alpha})) \) which allows us to decide how well our model represents the dataset.</li> 
</ul>
<p>
<p>We seek to minimize the function \( \mathcal{C} (\boldsymbol{x}, f(\boldsymbol{\alpha})) \) by finding the parameter values which minimize \( \mathcal{C} \). This leads to  various minimization algorithms. It may surprise many, but at the heart of all machine learning algortihms there is an optimization problem. </p>
</div>
</section>

<section>
<h2 id="low-level-machine-learning-the-family-of-ordinary-least-squares-methods">Low-level machine learning, the family of ordinary least squares methods  </h2>

<p>Our data which we want to apply a machine learning method on, consist
of a set of inputs \( \boldsymbol{x}^T=[x_0,x_1,x_2,\dots,x_{n-1}] \) and the
outputs we want to model \( \boldsymbol{y}^T=[y_0,y_1,y_2,\dots,y_{n-1}] \).
We assume  that the output data can be represented (for a regression case) by a continuous function \( f \)
through
</p>
<p>&nbsp;<br>
$$
\boldsymbol{y}=f(\boldsymbol{x})+\boldsymbol{\epsilon}.
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="setting-up-the-equations">Setting up the equations </h2>

<p>In linear regression we approximate the unknown function with another
continuous function \( \tilde{\boldsymbol{y}}(\boldsymbol{x}) \) which depends linearly on
some unknown parameters
\( \boldsymbol{\theta}^T=[\theta_0,\theta_1,\theta_2,\dots,\theta_{p-1}] \).
</p>

<p>The input data can be organized in terms of a so-called design matrix 
with an approximating function \( \boldsymbol{\tilde{y}} \) 
</p>
<p>&nbsp;<br>
$$
\boldsymbol{\tilde{y}}= \boldsymbol{X}\boldsymbol{\theta},
$$
<p>&nbsp;<br>
</section>

<section>
<h2 id="the-objective-cost-loss-function">The objective/cost/loss function </h2>

<p>The  simplest approach is the mean squared error</p>
<p>&nbsp;<br>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\sum_{i=0}^{n-1}\left(y_i-\tilde{y}_i\right)^2=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)^T\left(\boldsymbol{y}-\boldsymbol{\tilde{y}}\right)\right\},
$$
<p>&nbsp;<br>

<p>or using the matrix \( \boldsymbol{X} \) and in a more compact matrix-vector notation as</p>
<p>&nbsp;<br>
$$
C(\boldsymbol{\Theta})=\frac{1}{n}\left\{\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)^T\left(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\theta}\right)\right\}.
$$
<p>&nbsp;<br>

<p>This function represents one of many possible ways to define the so-called cost function.</p>
</section>

<section>
<h2 id="training-solution">Training solution  </h2>

<p>Optimizing with respect to the unknown parameters \( \theta_j \) we get </p>
<p>&nbsp;<br>
$$
\boldsymbol{X}^T\boldsymbol{y} = \boldsymbol{X}^T\boldsymbol{X}\boldsymbol{\theta},  
$$
<p>&nbsp;<br>

<p>and if the matrix \( \boldsymbol{X}^T\boldsymbol{X} \) is invertible we have the optimal values</p>
<p>&nbsp;<br>
$$
\hat{\boldsymbol{\theta}} =\left(\boldsymbol{X}^T\boldsymbol{X}\right)^{-1}\boldsymbol{X}^T\boldsymbol{y}.
$$
<p>&nbsp;<br>

<p>We say we 'learn' the unknown parameters \( \boldsymbol{\theta} \) from the last equation.</p>
</section>

<section>
<h2 id="selected-references">Selected references </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ul>
<p><li> <a href="https://arxiv.org/abs/1803.08823" target="_blank">Mehta et al.</a> and <a href="https://www.sciencedirect.com/science/article/pii/S0370157319300766?via%3Dihub" target="_blank">Physics Reports (2019)</a>.</li>
<p><li> <a href="https://link.aps.org/doi/10.1103/RevModPhys.91.045002" target="_blank">Machine Learning and the Physical Sciences by Carleo et al</a></li>
<p><li> <a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.94.031003" target="_blank">Artificial Intelligence and Machine Learning in Nuclear Physics, Amber Boehnlein et al., Reviews Modern of Physics 94, 031003 (2022)</a></li> 
<p><li> <a href="https://journals.aps.org/prresearch/pdf/10.1103/PhysRevResearch.5.033062" target="_blank">Dilute neutron star matter from neural-network quantum states by Fore et al, Physical Review Research 5, 033062 (2023)</a></li>
<p><li> <a href="https://doi.org/10.48550/arXiv.2305.08831" target="_blank">Neural-network quantum states for ultra-cold Fermi gases, Jane Kim et al, Nature Physics Communcication, submitted</a></li>
<p><li> <a href="https://doi.org/10.48550/arXiv.2305.07240" target="_blank">Message-Passing Neural Quantum States for the Homogeneous Electron Gas, Gabriel Pescia, Jane Kim et al. arXiv.2305.07240,</a></li>
<p><li> "Efficient solutions of fermionic systems using artificial neural networks, Nordhagen et al, Frontiers in Physics</li>
</ul>
</div>
</section>

<section>
<h2 id="machine-learning-a-simple-perspective-on-the-interface-between-ml-and-physics">Machine learning. A simple perspective on the interface between ML and Physics </h2>

<br/><br/>
<center>
<p><img src="figures/mlimage.png" width="800" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="ml-in-nuclear-physics-or-any-field-in-physics">ML in Nuclear  Physics (or any field in physics) </h2>

<br/><br/>
<center>
<p><img src="figures/ML-NP.png" width="900" align="bottom"></p>
</center>
<br/><br/>
</section>

<section>
<h2 id="phase-transitions-and-critical-phenomena">Phase Transitions and Critical Phenomena </h2>

<ol>
<p><li> Definition: A phase transition is characterized by an abrupt, non-analytic change in a macroscopic property of a system as some external parameter (e.g. temperature) is varied . In simpler terms, the system&#8217;s state or phase changes dramatically at a critical point.</li>
<p><li> Order Parameter: Associated with each phase transition is an order parameter &#8211; a quantity that is zero in one phase and non-zero in the other. For example, magnetization plays the role of an order parameter in magnetic systems, distinguishing ordered (magnetized) from disordered (unmagnetized) phases.</li>
<p><li> Critical Point: At the critical temperature (or pressure, etc.), the order parameter changes (continuous or discontinuous) and the system exhibits critical phenomena: large fluctuations, divergence of correlation length, and the onset of scale invariance. Critical points of second-order transitions feature continuous change of the order parameter with characteristic critical exponents and universal behavior across different systems.</li>
</ol>
</section>

<section>
<h2 id="phase-transitions-definitions">Phase Transitions: Definitions </h2>
<ol>
<p><li> A <em>phase transition</em> is a qualitative change in the state of a system when a control parameter (e.g.\ temperature) passes a critical point.</li>
<p><li> <b>Order parameter</b>: quantity that distinguishes phases (e.g.\ magnetization \( M \) for magnetic systems).</li>
<p><li> <b>Order vs disorder</b>: e.g.\ below \( T_c \) a ferromagnet has \( |M|>0 \) (ordered), above \( T_c \) $M=0$ (disordered).</li>
<p><li> Phases can break symmetries; transitions can be \emph{continuous} (second-order) or \emph{first-order}.</li>
</ol>
</section>

<section>
<h2 id="order-parameter-and-symmetry-breaking">Order Parameter and Symmetry Breaking </h2>
<ol>
<p><li> Phase transitions often involve spontaneous symmetry breaking (e.g.\ Ising model \( Z_2 \) symmetry).</li>
<p><li> The order parameter (e.g.\ magnetization \( M = \frac{1}{N}\sum_i s_i \)) changes behavior at \( T_c \).</li>
<p><li> In ferromagnets: \( M=0 \) for \( T>T_c \) (symmetric paramagnet), \( M\neq 0 \) for \( T < T_c \) (broken symmetry).</li>
<p><li> Example: in 2D Ising model, two symmetric ordered states (up/down) below \( T_c \).</li>
</ol>
</section>

<section>
<h2 id="phase-transitions-overview">Phase Transitions: Overview </h2>

<ol>
<p><li> <b>Definition</b>: A phase transition is characterized by an abrupt, non-analytic change in a macroscopic property of a system as some external parameter (e.g. temperature) is varied . In simpler terms, the system&#8217;s state or phase changes dramatically at a critical point.</li>
<p><li> <b>Order Parameter</b>: Associated with each phase transition is an order parameter &#8211; a quantity that is zero in one phase and non-zero in the other. For example, magnetization plays the role of an order parameter in magnetic systems, distinguishing ordered (magnetized) from disordered (unmagnetized) phases.</li>
<p><li> <b>Critical Point</b>: At the critical temperature (or pressure, etc.), the order parameter changes (continuous or discontinuous) and the system exhibits critical phenomena: large fluctuations, divergence of correlation length, and the onset of scale invariance. Critical points of second-order transitions feature continuous change of the order parameter with characteristic critical exponents and universal behavior across different systems.</li>
</ol>
</section>

<section>
<h2 id="phase-transitions-first-vs-second-order">Phase Transitions: First vs Second Order </h2>

<ol>
<p><li> <b>First-Order vs Second-Order</b>: In a first-order transition, the order parameter changes discontinuously at the transition (often with latent heat), whereas in a second-order (continuous) transition, the order parameter goes to zero continuously at \( T_c \), accompanied by diverging susceptibility and correlation length. For example, the liquid&#8211;gas transition (at sub-critical pressures) is first-order, while the ferromagnetic transition in the 2D Ising model is second-order (continuous).</li>
<p><li> <b>Example, Potts Model Transitions</b>: The q-state Potts model generalizes Ising (which is q=2). In 2D, the Potts model undergoes a continuous transition for \( q \le  4 \) and a discontinuous (first-order) transition for \( q>4 \) . This highlights how the nature of the phase transition can change with system parameters.</li>
<p><li> <b>Critical Phenomena</b>: Near second-order transitions, critical phenomena include power-law divergences (e.g. specific heat, susceptibility), critical opalescence (fluctuations at all scales), and universality (different systems share the same critical exponents if they have the same symmetry and dimensionality). These concepts set the stage for identifying phase transitions through data features (e.g. large fluctuations near \( T_c \) might be detectable by learning algorithms).</li>
</ol>
</section>

<section>
<h2 id="critical-phenomena-and-scaling">Critical Phenomena and Scaling </h2>

<ol>
<p><li> Near a continuous transition, observables follow power laws: \( M \sim |T-T_c|^\beta \), correlation length \( \xi \sim |T-T_c|^{-\nu} \), etc.</li>
<p><li> <b>Critical exponents</b> (\( \alpha,\beta,\gamma,\nu,\dots \)) characterize singular behavior.</li>
<p><li> Universality: systems with the same symmetry and dimension share exponents.</li>
<p><li> The classical example is the  two-dimensional  Ising exponents known analytically (Onsager).</li>
<p><li> At \( T\to T_c \), correlation length \( \xi\to\infty \), large-scale fluctuations appear.</li>
</ol>
</section>

<section>
<h2 id="2d-ising-model-definition">2D Ising Model: Definition </h2>
<ol>
<p><li> Spins \( s_i = \pm 1 \) on a 2D square lattice, nearest-neighbor ferromagnetic coupling.</li>
<p><li> Hamiltonian: \( H = -J \sum_{\langle i,j\rangle} s_i s_j, \) with \( J>0 \) favoring alignment.</li>
<p><li> Exhibits a second-order phase transition at critical temperature \( T_c \).</li>
<p><li> Order parameter: magnetization \( M = \frac{1}{N}\sum_i s_i \).</li>
<p><li> Below \( T_c \), \( M\neq0 \) (ferromagnetic order); above \( T_c \), \( M=0 \) (paramagnet).</li>
</ol>
</section>

<section>
<h2 id="2d-ising-model-critical-temperature">2D Ising Model: Critical Temperature </h2>
<ol>
<p><li> Exact result (Onsager): critical point \( T_c \) satisfies \( T_c \approx \frac{2J}{\ln(1+\sqrt{2})}\approx 2.269J \).</li>
<p><li> At \( T>T_c \): spins are mostly disordered, no net magnetization.</li>
<p><li> At \( T < T_c \): long-range order develops (nonzero \( M \)).</li>
<p><li> Correlation length \( \xi \) diverges at \( T_c \)</li> 
<p><li> Example: at \( T=T_c \) large clusters of aligned spins appear.</li>
</ol>
</section>

<section>
<h2 id="q-state-potts-model-definition">q-State Potts Model: Definition </h2>
<ul>
<p><li> Generalization of Ising: each spin \( s_i \in \{1,2,\dots,q\} \).</li>
<p><li> Ferromagnetic Potts Hamiltonian:</li>
</ul>
<p>
<p>&nbsp;<br>
$$
       H = -J \sum_{\langle i,j\rangle} \delta_{s_i,s_j},
     $$
<p>&nbsp;<br>

<p>where \( \delta_{a,b}=1 \) if \( a=b \), else \( 0 \).</p>
<ul>
<p><li> If \( q=2 \), reduces to the Ising model. Higher \( q \) allows richer symmetry breaking (\( \mathbb{Z}_q \)).</li>
<p><li> Widely used to study phase transitions with multiple equivalent ordered states.</li>
</ul>
</section>

<section>
<h2 id="2d-potts-model-phase-behavior">2D Potts Model: Phase Behavior </h2>
<ul>
<p><li> In 2D, the ferromagnetic Potts model has a phase transition for all \( q\ge1 \)</li> 
<p><li> Exact critical point:</li>
</ul>
<p>
<p>&nbsp;<br>
$$
       \frac{J}{k_B T_c} = \ln\!\bigl(1+\sqrt{q}\bigr).
     $$
<p>&nbsp;<br>

<ul>
<p><li> The nature of the transition depends on \( q \)</li> 
<ul>

<p><li> \( 1 \le q \le 4 \): continuous (second-order) transition.</li>

<p><li> \( q > 4 \): discontinuous (first-order) transition (latent heat appears).</li>
</ul>
<p>
<p><li> Example: \( q=3,4 \) have continuous transitions; \( q=5 \) and higher show first-order behavior.</li>
</ul>
</section>

<section>
<h2 id="monte-carlo-sampling-of-spin-models">Monte Carlo Sampling of Spin Models </h2>
<ol>
<p><li> Use Monte Carlo (MC) to generate spin configurations at given \( T \): sample from Boltzmann distribution \( P\propto e^{-H/T} \).</li>
<p><li> Metropolis algorithm: attempt random single-spin flips to equilibrate the system.</li>
<p><li> Provides training data: spin configurations \( \{s_i\} \) labeled by temperature or phase.</li>
<p><li> Ensures statistical equilibrium and detailed balance</li> 
<p><li> Efficient sampling (especially near \( T_c \) cluster algorithms help, e.g.\ Wolff or Swendsen-Wang).</li>
</ol>
</section>

<section>
<h2 id="metropolis-algorithm">Metropolis Algorithm </h2>
<ul>
<p><li> Initialize spins randomly or in a fixed state.</li>
<p><li> Repeat for many steps:
<ol type="a"></li>
 <p><li> Pick a random lattice site \( i \).</li>
 <p><li> Propose flipping \( s_i \to -s_i \) (Ising) or change state (Potts).</li>
 <p><li> Compute energy change \( \Delta E \).</li>
 <p><li> If \( \Delta E \le 0 \), accept the flip (lower energy).</li>
 <p><li> Else accept with probability \( \exp(-\Delta E/T) \) (Boltzmann factor)</li>

<p><li> Otherwise, reject and keep the old state.</li>
</ol>
<p>
<p><li> After equilibration, record configurations as samples.</li>
</ul>
</section>

<section>
<h2 id="metropolis-algorithm-pseudo-code">Metropolis Algorithm (Pseudo-code) </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">for</span> T <span style="color: #8B008B">in</span> temperature_list:
   <span style="color: #228B22"># Initialize lattice (e.g., random spins)</span>
   config = random_configuration(Lx, Ly)
   <span style="color: #8B008B; font-weight: bold">for</span> step <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(num_steps):
       i,j = random_site()
       dE = compute_deltaE(config, i, j)  <span style="color: #228B22"># energy change if spin flipped</span>
       <span style="color: #8B008B; font-weight: bold">if</span> dE &lt;= <span style="color: #B452CD">0</span> <span style="color: #8B008B">or</span> rand() &lt; exp(-dE/T):
           flip_spin(config, i, j)
   record_configuration(config, T)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="monte-carlo-data-for-ml">Monte Carlo Data for ML </h2>
<ol>
<p><li> Generate many spin configurations across a range of temperatures \( T \).</li>
<p><li> Label each configuration by its temperature or by phase (ordered/disordered).</li>
<p><li> This labeled dataset is used for \emph{supervised} methods (e.g.\ CNN).</li>
<p><li> For \emph{unsupervised} methods (PCA, VAE), labels are not used in training.</li>
<p><li> Data augmentation: one can use symmetries (e.g.\ spin flip) to enlarge dataset.</li>
</ol>
</section>

<section>
<h2 id="principal-component-analysis-pca-basics">Principal Component Analysis (PCA) Basics </h2>

<ol>
<p><li> PCA is an unsupervised method for dimensionality reduction.</li>
<p><li> Finds orthogonal directions (principal components) of maximum variance in data.</li>
<p><li> Project data onto the first few PCs to visualize structure.</li>
<p><li> Advantages: linear, fast, and interpretable (PCs are linear combinations of features).</li>
<p><li> Disadvantage: only captures linear correlations (may miss complex features).</li>
</ol>
</section>

<section>
<h2 id="pca-for-phase-identification">PCA for Phase Identification </h2>
<ol>
<p><li> Apply PCA to the ensemble of spin configurations (flattened to vectors).</li>
<p><li> The first principal component (PC1) often correlates with the order parameter (e.g.\ magnetization).</li>
<p><li> Hu et al. (2017) found PCA distinguishes different phases and can locate critical points</li> 
<p><li> By plotting data in the subspace of PCs, one sees separation of low-\( T \) (ordered) vs high-\( T \) (disordered) points.</li>
<p><li> No labels needed: phase transitions are revealed by clustering in PC space</li> 
</ol>
</section>

<section>
<h2 id="pca-workflow-for-spin-data">PCA Workflow for Spin Data </h2>

<ol>
<p><li> Collect data matrix \( X \) of shape (num\_samples) \( \times \) (num\_features), e.g. \( N\times (L\times L) \).</li>
<p><li> Subtract the mean from each column (feature) of \( X \).</li>
<p><li> Compute covariance matrix \( C = X^T X \) (or use SVD on \( X \) directly).</li>
<p><li> Obtain eigenvalues/vectors of \( C \): \( C = U \Lambda U^T \). Columns of \( U \) are principal directions.</li>
<p><li> Sort by eigenvalues (variance). Project \( X \) onto top \( k \) PCs: \( X_{\rm red} = X\,U[:,1:k] \).</li>
<p><li> Analyze \( X_{\rm red} \): e.g. scatter plot PC1 vs PC2.</li>
</ol>
</section>

<section>
<h2 id="pca-example-ising-model">PCA Example: Ising Model </h2>

<ol>
<p><li> In the 2D Ising model, PC1 is essentially proportional to the overall magnetization.</li>
<p><li> At \( T < T_c \), configurations cluster with large positive or negative PC1 (ordered states).</li>
<p><li> At \( T>T_c \), configurations cluster near \( PC1 \approx 0 \) (disordered).</li>
<p><li> The variance captured by PC1 drops sharply at \( T_c \), signaling the transition.</li>
<p><li> PCA automatically finds these features, without knowing the physics a priori.</li>
</ol>
</section>

<section>
<h2 id="pca-limitations">PCA Limitations </h2>
<ol>
<p><li> PCA is linear: complex nonlinear features (e.g.\ vortex order) may not be captured.</li>
<p><li> Example: In a frustrated 2D spin model, PCA failed to detect certain correlations (vorticity)</li> 
<p><li> PCA does not directly classify; it provides features for clustering or visualization.</li>
<p><li> Sensitive to scaling: data should be normalized appropriately.</li>
<p><li> Still useful as a first-pass: identifies the most significant variations</li> 
</ol>
</section>

<section>
<h2 id="pca-with-pytorch-example-code">PCA with PyTorch (Example Code) </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch</span>

<span style="color: #228B22"># X: tensor of shape (N, L*L) containing spin configurations as floats (e.g. +1/-1)</span>
<span style="color: #228B22"># Center the data</span>
X = X - X.mean(dim=<span style="color: #B452CD">0</span>, keepdim=<span style="color: #8B008B; font-weight: bold">True</span>)

<span style="color: #228B22"># Compute covariance (or use torch.pca_lowrank)</span>
cov = torch.mm(X.t(), X) / (X.size(<span style="color: #B452CD">0</span>)-<span style="color: #B452CD">1</span>)

<span style="color: #228B22"># Eigen-decomposition (SVD) of covariance</span>
U, S, V = torch.svd(cov)

<span style="color: #228B22"># Select first k principal components</span>
k = <span style="color: #B452CD">2</span>
PCs = U[:, :k]  <span style="color: #228B22"># shape (L*L, k)</span>

<span style="color: #228B22"># Project data onto principal components</span>
X_reduced = torch.mm(X, PCs)  <span style="color: #228B22"># shape (N, k)</span>
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="convolutional-neural-networks-cnns">Convolutional Neural Networks (CNNs) </h2>

<ol>
<p><li> CNNs are deep neural networks designed for spatial data (e.g. images).</li>
<p><li> Architecture: convolutional layers (feature detectors) + pooling, followed by fully connected layers.</li>
<p><li> In physics: treat spin lattice as an image with multiple channels (e.g.\ one channel of spins).</li>
<p><li> CNNs can learn complex nonlinear features automatically from data.</li>
<p><li> They require labeled examples for training (supervised learning).</li>
</ol>
</section>

<section>
<h2 id="cnn-for-phase-classification">CNN for Phase Classification </h2>
<ol>
<p><li> Prepare training data: spin configurations labeled by phase or temperature.</li>
<p><li> CNN learns to map configuration \( \to \) phase label (ordered/disordered) or predict \( T \).</li>
<p><li> As shown by Carrasquilla and Melko (2017), CNNs can identify phases from raw states</li> 
<p><li> Achieves high accuracy on Ising and other models when training labels are available.</li>
<p><li> CNNs exploit locality: can detect clusters or domains of aligned spins via convolution filters.</li>
</ol>
</section>

<section>
<h2 id="example-cnn-architecture">Example CNN Architecture </h2>
<ol>
<p><li> <b>Input</b>: single-channel \( L\times L \) lattice (values \( -1 \) or \( +1 \)).</li>
<p><li> <b>Conv layer 1</b>: e.g.\ 8 filters of size \( 3\times3 \), ReLU activation, stride=1, padding=1.</li>
<p><li> <b>Conv layer 2</b>: 16 filters of size \( 3\times3 \), ReLU, followed by a \( 2\times2 \) max-pooling.</li>
<p><li> <b>Fully Connected</b>: flatten feature maps to vector; FC layer to 64 units (ReLU); final FC to 2 outputs (softmax for binary phase).</li>
<p><li> <b>Training</b>: minimize cross-entropy loss between predicted and true labels.</li>
<p><li> <b>Note</b>: architecture and hyperparameters can be tuned for best performance.</li>
</ol>
</section>

<section>
<h2 id="cnn-training-and-results">CNN: Training and Results </h2>
<ol>
<p><li> Train on many labeled samples (e.g.\ temperatures \( T \) and whether \( T < T_c \) or \( T>T_c \)).</li>
<p><li> The network learns features such as magnetization domains, energy patterns, etc.</li>
<p><li> CNN accuracy can be very high (often $\sim$100\% on clean data) for distinguishing phases.</li>
<p><li> Fukushima and Sakai (2021): a CNN trained on 2D Ising can detect transition in \( q \)-state Potts</li> 
<p><li> CNN behavior: at high \( T \) it effectively uses average energy; at low \( T \) it correlates with magnetization</li> 
</ol>
</section>

<section>
<h2 id="cnn-interpretability">CNN Interpretability </h2>
<ol>
<p><li> CNNs are often seen as <b>black boxes</b>, but their learned filters can sometimes be interpreted.</li>
<p><li> Outputs correlate with known physics:
<ol type="a"></li>
 <p><li> At low \( T \): classification heavily influenced by magnetization (order).</li>
 <p><li> At high \( T \): classification influenced by internal energy (disorder)</li> 
</ol>
<p>
<p><li> CNNs can generalize: e.g.\ Ising-trained CNN finds Potts \( T_c \)</li> 
<p><li> Visualization methods (e.g.\ saliency maps) can highlight what CNN focuses on.</li>
</ol>
</section>

<section>
<h2 id="cnn-pytorch-code-example">CNN (PyTorch) Code Example </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch.nn</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">nn</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch.nn.functional</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">F</span>

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">PhaseCNN</span>(nn.Module):
   <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, L):
       <span style="color: #658b00">super</span>(PhaseCNN, <span style="color: #658b00">self</span>).<span style="color: #008b45">__init__</span>()
       <span style="color: #658b00">self</span>.conv1 = nn.Conv2d(<span style="color: #B452CD">1</span>, <span style="color: #B452CD">8</span>, kernel_size=<span style="color: #B452CD">3</span>, padding=<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># 1 channel -&gt; 8</span>
       <span style="color: #658b00">self</span>.conv2 = nn.Conv2d(<span style="color: #B452CD">8</span>, <span style="color: #B452CD">16</span>, kernel_size=<span style="color: #B452CD">3</span>, padding=<span style="color: #B452CD">1</span>) <span style="color: #228B22"># 8 -&gt; 16</span>
       <span style="color: #658b00">self</span>.pool = nn.MaxPool2d(<span style="color: #B452CD">2</span>)  <span style="color: #228B22"># downsample by 2</span>
       <span style="color: #658b00">self</span>.fc1 = nn.Linear(<span style="color: #B452CD">16</span> * (L//<span style="color: #B452CD">2</span>) * (L//<span style="color: #B452CD">2</span>), <span style="color: #B452CD">64</span>)
       <span style="color: #658b00">self</span>.fc2 = nn.Linear(<span style="color: #B452CD">64</span>, <span style="color: #B452CD">2</span>)  <span style="color: #228B22"># 2 output classes</span>

   <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">forward</span>(<span style="color: #658b00">self</span>, x):
       x = F.relu(<span style="color: #658b00">self</span>.conv1(x))      <span style="color: #228B22"># (B,8,L,L)</span>
       x = <span style="color: #658b00">self</span>.pool(F.relu(<span style="color: #658b00">self</span>.conv2(x)))  <span style="color: #228B22"># (B,16,L/2,L/2)</span>
       x = x.view(x.size(<span style="color: #B452CD">0</span>), -<span style="color: #B452CD">1</span>)      <span style="color: #228B22"># flatten</span>
       x = F.relu(<span style="color: #658b00">self</span>.fc1(x))
       x = <span style="color: #658b00">self</span>.fc2(x)               <span style="color: #228B22"># logits for 2 classes</span>
       <span style="color: #8B008B; font-weight: bold">return</span> x

<span style="color: #228B22"># Example usage:</span>
model = PhaseCNN(L=<span style="color: #B452CD">32</span>)           <span style="color: #228B22"># for a 32x32 lattice</span>
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=<span style="color: #B452CD">1e-3</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="variational-autoencoders-vae-overview">Variational Autoencoders (VAE) Overview </h2>

<ol>
<p><li> A VAE is an \emph{unsupervised} generative model that learns a latent representation of data.</li>
<p><li> Components:
<ol type="a"></li>

<p><li> <b>Encoder</b>: maps input \( X \) to parameters \( (\mu, \log\sigma^2) \) of a latent Gaussian.</li>

<p><li> <b>Latent</b> \( z \): sampled via \( z = \mu + \sigma \epsilon \) (\( \epsilon\sim N(0,I) \)).</li>

<p><li> <b>Decoder</b>: reconstructs input \( \hat{X} \) from \( z \).</li>
</ol>
<p>
<p><li> Loss: reconstruction error + KL divergence to enforce latent prior \( \mathcal{N}(0,I) \).</li>
<p><li> VAEs can both encode data compactly and generate new samples by sampling \( z \).</li>
</ol>
</section>

<section>
<h2 id="vae-for-spin-configurations">VAE for Spin Configurations </h2>

<ol>
<p><li> Train VAE on spin configurations (no labels).</li>
<p><li> Latent space (usually low-dimensional) captures key features (like order parameter).</li>
<p><li> Walker et al. (2020): latent variables provide metrics to track order vs disorder in Ising</li> 
<p><li> They found the latent representation closely corresponds to physical order (magnetization)</li> 
<p><li> After training, one can:
<ol type="a"></li>
 <p><li> Inspect latent space (e.g.\ scatter plot of \( (\mu_1,\mu_2) \)) to distinguish phases.</li>
 <p><li> Sample \( z\sim N(0,1) \) and decode to generate synthetic configurations.</li>
</ol>
<p>
</ol>
</section>

<section>
<h2 id="vae-architecture-details">VAE Architecture Details </h2>

<ul>
<p><li> Typically use convolutional encoder/decoder for 2D structure.</li>
<p><li> Example:
<ol type="a"></li>
 <p><li> Encoder: conv layers downsampling to a flat vector \( \rightarrow \) linear layers \( \rightarrow (\mu, \log\sigma^2) \) (size of latent space, e.g.\ 2&#8211;10 dims).</li>
 <p><li> Decoder: linear layer from \( z \) to feature map size, followed by transposed-conv layers to reconstruct \( L\times L \) lattice.</li>
</ol>
<p>
<p><li> Activation: ReLU (or LeakyReLU); final output often sigmoid to model spin distribution.</li>
<p><li> Training with minibatch gradient descent optimizing</li>
</ul>
<p>
<p>&nbsp;<br>
$$
       \mathcal{L} = \mathbb{E}[\|X - \hat{X}\|^2] +
       \mathrm{KL}(\mathcal{N}(\mu,\sigma)\,\|\,\mathcal{N}(0,1)).
     $$
<p>&nbsp;<br>
</section>

<section>
<h2 id="vae-results-on-ising-model">VAE Results on Ising Model </h2>

<ol>
<p><li> The first latent dimension (\( \nu_0 \)) learned by the VAE correlated strongly with magnetization</li> 
<p><li> Plotting \( \nu_0 \) vs temperature shows clear change around \( T_c \) (order&#8211;disorder).</li>
<p><li> This means VAE "discovered" the order parameter without supervision.</li>
<p><li> The VAE predicted the critical region and crossover consistently with theory</li> 
<p><li> Latent space clustering: ordered-phase points separate from disordered.</li>
</ol>
</section>

<section>
<h2 id="vae-generation-and-interpretation">VAE: Generation and Interpretation </h2>

<ol>
<p><li> After training, sample random \( z \) from Gaussian prior and decode to generate configurations.</li>
<p><li> The VAE latent space is continuous: can interpolate between phases.</li>
<p><li> The learned representation is smooth and disentangled: one latent coordinate tracks magnetization, others track disorder.</li>
<p><li> VAEs can also be used for anomaly detection: points with unusual \( z \) indicate atypical states.</li>
<p><li> Overall, VAEs provide both a dimensionally-reduced view of phase structure and a generative model.</li>
</ol>
</section>

<section>
<h2 id="vae-pytorch-code-example">VAE (PyTorch) Code Example </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="font-size: 80%; line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch.nn</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">nn</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">torch.nn.functional</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">F</span>

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">VAE</span>(nn.Module):
   <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, L, latent_dim=<span style="color: #B452CD">2</span>):
       <span style="color: #658b00">super</span>(VAE, <span style="color: #658b00">self</span>).<span style="color: #008b45">__init__</span>()
       <span style="color: #228B22"># Encoder: conv -&gt; conv -&gt; flatten -&gt; fc_mu/fc_logvar</span>
       <span style="color: #658b00">self</span>.encoder = nn.Sequential(
           nn.Conv2d(<span style="color: #B452CD">1</span>, <span style="color: #B452CD">8</span>, <span style="color: #B452CD">3</span>, stride=<span style="color: #B452CD">2</span>, padding=<span style="color: #B452CD">1</span>),   <span style="color: #228B22"># -&gt; (8, L/2, L/2)</span>
           nn.ReLU(),
           nn.Conv2d(<span style="color: #B452CD">8</span>, <span style="color: #B452CD">16</span>, <span style="color: #B452CD">3</span>, stride=<span style="color: #B452CD">2</span>, padding=<span style="color: #B452CD">1</span>),  <span style="color: #228B22"># -&gt; (16, L/4, L/4)</span>
           nn.ReLU(),
           nn.Flatten()
       )
       <span style="color: #658b00">self</span>.fc_mu = nn.Linear(<span style="color: #B452CD">16</span>*(L//<span style="color: #B452CD">4</span>)*(L//<span style="color: #B452CD">4</span>), latent_dim)
       <span style="color: #658b00">self</span>.fc_logvar = nn.Linear(<span style="color: #B452CD">16</span>*(L//<span style="color: #B452CD">4</span>)*(L//<span style="color: #B452CD">4</span>), latent_dim)

       <span style="color: #228B22"># Decoder: linear -&gt; unflatten -&gt; convTranspose -&gt; convTranspose</span>
       <span style="color: #658b00">self</span>.decoder_fc = nn.Linear(latent_dim, <span style="color: #B452CD">16</span>*(L//<span style="color: #B452CD">4</span>)*(L//<span style="color: #B452CD">4</span>))
       <span style="color: #658b00">self</span>.decoder = nn.Sequential(
           nn.Unflatten(<span style="color: #B452CD">1</span>, (<span style="color: #B452CD">16</span>, L//<span style="color: #B452CD">4</span>, L//<span style="color: #B452CD">4</span>)),
           nn.ConvTranspose2d(<span style="color: #B452CD">16</span>, <span style="color: #B452CD">8</span>, <span style="color: #B452CD">3</span>, stride=<span style="color: #B452CD">2</span>, padding=<span style="color: #B452CD">1</span>, output_padding=<span style="color: #B452CD">1</span>),  <span style="color: #228B22"># -&gt; (8, L/2, L/2)</span>
           nn.ReLU(),
           nn.ConvTranspose2d(<span style="color: #B452CD">8</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">3</span>, stride=<span style="color: #B452CD">2</span>, padding=<span style="color: #B452CD">1</span>, output_padding=<span style="color: #B452CD">1</span>),   <span style="color: #228B22"># -&gt; (1, L, L)</span>
           nn.Sigmoid()
       )

   <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">encode</span>(<span style="color: #658b00">self</span>, x):
       h = <span style="color: #658b00">self</span>.encoder(x)
       mu = <span style="color: #658b00">self</span>.fc_mu(h)
       logvar = <span style="color: #658b00">self</span>.fc_logvar(h)
       <span style="color: #8B008B; font-weight: bold">return</span> mu, logvar

   <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">reparameterize</span>(<span style="color: #658b00">self</span>, mu, logvar):
       std = torch.exp(<span style="color: #B452CD">0.5</span>*logvar)
       eps = torch.randn_like(std)
       <span style="color: #8B008B; font-weight: bold">return</span> mu + eps * std

   <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">decode</span>(<span style="color: #658b00">self</span>, z):
       h = <span style="color: #658b00">self</span>.decoder_fc(z)
       x_recon = <span style="color: #658b00">self</span>.decoder(h)
       <span style="color: #8B008B; font-weight: bold">return</span> x_recon

   <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">forward</span>(<span style="color: #658b00">self</span>, x):
       mu, logvar = <span style="color: #658b00">self</span>.encode(x)
       z = <span style="color: #658b00">self</span>.reparameterize(mu, logvar)
       x_recon = <span style="color: #658b00">self</span>.decode(z)
       <span style="color: #8B008B; font-weight: bold">return</span> x_recon, mu, logvar

<span style="color: #228B22"># Example instantiation:</span>
model = VAE(L=<span style="color: #B452CD">32</span>, latent_dim=<span style="color: #B452CD">2</span>)
optimizer = torch.optim.Adam(model.parameters(), lr=<span style="color: #B452CD">1e-3</span>)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
</section>

<section>
<h2 id="supervised-vs-unsupervised-methods">Supervised vs Unsupervised Methods </h2>

<ol>
<p><li> <b>Supervised (CNN)</b>: Requires labeled data (phase labels or temperatures). Learns a direct mapping \( \{\text{config}\}\to\{\text{phase}\} \).</li>
<p><li> <b>Unsupervised (PCA, VAE)</b>: Uses only the raw configurations without labels. Learns features or representations of the data.</li>
<p><li> PCA reduces dimensionality; requires no training labels</li> 
<p><li> VAE learns a latent generative model; also label-free</li> 
<p><li> CNN typically achieves higher accuracy in classifying known phases, but needs supervised labels.</li>
</ol>
</section>

<section>
<h2 id="method-interpretability-and-features">Method Interpretability and Features </h2>

<ol>
<p><li> <b>PCA</b>: Principal components often have clear physical meaning (e.g.\ PC1 and  magnetization)</li> 
<p><li> <b>CNN</b>: Filters are less directly interpretable; features are learned. However, some correlation with physics (energy, \( M \)) emerges</li> 
<p><li> <b>VAE</b>: Latent variables can often be interpreted as order/disorder features (e.g. one latent is approximately equal to the  magnetization)</li> 
<p><li> CNN is a "black box" classifier; PCA/VAE provide insight into data structure.</li>
<p><li> In terms of visualization: PCA and VAE produce low-dim plots of data (semi-transparent), whereas CNN only outputs a decision boundary.</li>
</ol>
</section>

<section>
<h2 id="performance-and-use-cases">Performance and Use Cases </h2>

<ol>
<p><li> <b>PCA</b>: Fast to compute; good for preliminary analysis of large datasets. Best for linearizable transitions.</li>
<p><li> <b>CNN</b>: High classification accuracy; powerful for large and complex datasets. Can predict critical \( T \) or classify multiple phases</li> 
<p><li> <b>VAE</b>: Useful when no labels are available; provides a generative model. Effective in detecting transitions by latent statistics</li> 
<p><li> Computational cost: PCA very cheap, CNN and VAE require training time (GPU recommended for large data).</li>
<p><li> Choosing a method: depends on data availability and goal (classification vs insight vs generation).</li>
</ol>
</section>

<section>
<h2 id="summary-of-methods">Summary of Methods </h2>
<ol>
<p><li> <b>PCA</b>: Unsupervised, linear, interpretable. Good for dimensionality reduction and initial exploration</li>
<p><li> <b>CNN</b>: Supervised, non-linear, high accuracy. Requires labels, but learns complex features (works across models</li> 
<p><li> <b>VAE</b>: Unsupervised, generative. Learns latent representation reflecting order/disorder</li> 
<p><li> Each method has trade-offs in accuracy, interpretability, and data requirements.</li>
<p><li> Combining methods (e.g.\ using PCA or VAE features as input to another classifier) can also be fruitful.</li>
</ol>
</section>

<section>
<h2 id="conclusions">Conclusions </h2>
<ol>
<p><li> Machine learning provides powerful tools for studying phase transitions in statistical models.</li>
<p><li> <em>Unsupervised</em> methods (PCA, VAE) can discover phase structure without labels</li> 
<p><li> <em>Supervised</em> methods (CNNs) achieve high classification performance given labeled data</li> 
<p><li> Interpretability: PCA/VAE offer more insight into physics (latent/PC represent order parameters), while CNNs focus on prediction accuracy.</li>
<p><li> Choice of method depends on the problem: data availability, need for generative modeling, and interpretability.</li>
<p><li> Future directions: deeper architectures (e.g.\ ResNets), unsupervised generative flows, transfer learning across models, real experimental data.</li>
</ol>
</section>

<section>
<h2 id="references">References </h2>
<ol>
<p><li> Carrasquilla, J. \& Melko, R. G. (2017). Machine learning phases of matter. \emph{Nature Physics}, 13, 431&#8211;434</li> 
<p><li> Hu, W. \textit{et al.} (2017). Discovering phases, phase transitions through unsupervised ML. \emph{Phys. Rev. E} 95, 062122</li> 
<p><li> Fukushima, K. \& Sakai, K. (2021). Can a CNN trained on Ising detect Potts? \emph{Prog. Theor. Exp. Phys.} 2021, 061A01</li> 
<p><li> Walker, N. \textit{et al.} (2020). 2D Ising model crossover via VAE. \emph{Sci. Rep.} 10, 13047</li>
<p><li> Add refs</li>
</ol>
</section>



</div> <!-- class="slides" -->
</div> <!-- class="reveal" -->

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

  // Display navigation controls in the bottom right corner
  controls: true,

  // Display progress bar (below the horiz. slider)
  progress: true,

  // Display the page number of the current slide
  slideNumber: true,

  // Push each slide change to the browser history
  history: false,

  // Enable keyboard shortcuts for navigation
  keyboard: true,

  // Enable the slide overview mode
  overview: true,

  // Vertical centering of slides
  //center: true,
  center: false,

  // Enables touch navigation on devices with touch input
  touch: true,

  // Loop the presentation
  loop: false,

  // Change the presentation direction to be RTL
  rtl: false,

  // Turns fragments on and off globally
  fragments: true,

  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,

  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,

  // Stop auto-sliding after user input
  autoSlideStoppable: true,

  // Enable slide navigation via mouse wheel
  mouseWheel: false,

  // Hides the address bar on mobile devices
  hideAddressBar: true,

  // Opens links in an iframe preview overlay
  previewLinks: false,

  // Transition style
  transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

  // Transition speed
  transitionSpeed: 'default', // default/fast/slow

  // Transition style for full page slide backgrounds
  backgroundTransition: 'default', // default/none/slide/concave/convex/zoom

  // Number of slides away from the current that are visible
  viewDistance: 3,

  // Parallax background image
    //parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

  // Parallax background size
  //parallaxBackgroundSize: '' // CSS syntax, e.g. "2100px 900px"

  theme: Reveal.getQueryHash().theme, // available themes are in reveal.js/css/theme
    transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/none

});

Reveal.initialize({
  dependencies: [
      // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

      // Interpret Markdown in <section> elements
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

      // Syntax highlight for <code> elements
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

      // Zoom in and out with Alt+click
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

      // Speaker notes
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

      // Remote control your reveal.js presentation using a touch device
      //{ src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

      // MathJax
      //{ src: 'reveal.js/plugin/math/math.js', async: true }
  ]
});

Reveal.initialize({

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1170,  // original: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.0

});
</script>

<!-- begin footer logo
<div style="position: absolute; bottom: 0px; left: 0; margin-left: 0px">
<img src="somelogo.png">
</div>
   end footer logo -->




</body>
</html>
